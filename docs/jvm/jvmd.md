

## [读书笔记] 深入理解Java虚拟机：JVM高级特性与最佳实践



# 二. 自动内存管理机制

## 2.1 内存区域

![虚拟机运行地址](https://user-images.githubusercontent.com/24818340/132078793-44b4d039-7e41-4691-b532-5597d8bbf191.png)

> 方法区

- 线程共享.用于存储已被虚拟机加载的类信息（类名，访问修饰符，常量池，字段描述，方法描述），常量，静态变量，即时编译后的代码等.别名也叫非堆.
**对于Hotpot虚拟机，使用永久代实现方法区，但两者并不等价.**

- 垃圾回收在这个区域比较少出现.此区域的回收目标主要是针对常量池的回收和对类型的卸载.

- 内存不足也可以抛出OOM.对类进行增强时，增强的类越多,就需要越大的方法区来保证动态生成的class可以加载入内存.

>> 运行时常量池

- 方法区一部分.class文件除了有类版本，字段，方法，接口等描述信息，还有常量池（用于存放编译器生成的各种字面量和符号引用），这部分将在类加载后存放到方法区的运行时常量池.

- 具有动态性.java语言不要求常量一定在编译器产生，运行期间也可能将新的常量放入池中.这种特性利用最多的就是String的intern方法

- 一般来说除了保存Class文件中描述的符号引用，还会把翻译出来的直接引用也存储在这部分.同事也会抛出OOM错误.



> 虚拟机栈

- 线程私有.生命周期和线程相同，每个方法运行同时都会创建一个**栈帧**（**用于存储局部变量表，操作栈，动态链接，方法出口**）.每个方法调用至执行完成，对应一个栈帧在虚拟机栈入栈到出栈的过程.

- 局部变量表存放了编译期已知的各种基本数据类型，对象引用（reference类型，他不等同于对象本身，根据不同虚拟机实现;它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向一条字节码的地址）

- 局部变量表所需的内存空间在编译器完成分配。




> 本地方法栈

- 本地方法栈作用和虚拟机栈作用类似，只不过本地方法栈执行的native方法.某些虚拟机如Sun HotPot将两者合二为一.

> 堆

- 线程公有.在虚拟机启动的时候创建，唯一目的是存放对象实例.（虚拟机规范为 对象实例和数组在堆上分配）. 随着JIT编译器发展和逃逸分析，**栈上分配/优化技术（内存逃逸分析）**将会导致一些变化.

- 根据分代收集的内存回收机制，可以分为新生代 老年代  持久代

> 程序计数器

- 线程私有.较小的内存区域，作用为当前线程所执行字节码的行号指示器。工作概念为改变计数器的值选取下一条需要执行的字节码指令.（JAVA多线程通过线程轮流切换并分配处理器执行时间，为了每个线程都能分配到正确执行位置，所以每个线程都有一个线程计数器）
   
- 如果执行java方法，计数器记录正在执行的虚拟机字节码指令地址;如果执行native地址，计数器为空; **此内存区域是唯一一个在jvm内存区域没有OOM的区域。**


> 直接内存

- 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范的内存区域.
- 在JDK1.4加入了NIO类，引入了一种基于通道与缓存区（Buffer）的I/O方式，它可以使用native函数库直接分配堆外内存，然后通过存储在堆里面的DirectByteBuffer对象作为这块内存的引用进行操作.这样可以显著提高效率.避免在堆和native堆来回复制数据,提高速度
- 	


## 2.2 对象访问

- 不同虚拟机实现对象访问的方式会有所不同，主流的访问方式有两种：使用句柄和直接指针

- 使用句柄：

> java堆划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址. 优势：每次改变数据，只会改变句柄中的实例地址，而reference本身不需要修改.


- 直接指针：

> java堆对象的布局就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是存储地址. 优势速度更快，Sun hotpot使用这种.

## 2.3 常见JVM排查

> 2.3.1 JVM堆溢出

- 首先dump出当前jvm快照
- 使用内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确定内存是否必要.即判断 **内存泄漏 还是内存溢出**
- 如果是内存泄漏，可以通过工具查看泄漏对象到GC Roots的引用链.掌握了泄漏对象的类信息，以及Gc Roots引用链的信息，就可以准确地定位出泄漏代码的位置.
- 如果不存在泄漏，则内存中的数据都必须活着.**物理上检查虚拟机参数，Xms/ xmx。代码中检查某些对象是否生命周期过长，持有时间过长的情况**，尝试减少程序运行期间的内存消耗.

- 技巧：将Xms和Xmx参数设置成一样，可以避免堆自动扩容.
- -XX:+HeadDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出时Dump出当前的内存堆转储快照以便事后进行分析


> 2.3.2 虚拟机栈和本地方法栈溢出

- 由于在HotSpot中，不区分虚拟机栈和本地方法栈.所以对于参数 -Xoss（设置本地方法栈大小）虽然存在，但是不生效.栈容量只由-Xss参数设定.

- JVM定义了两种异常;

> 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflawError; 

> 大部分虚拟机可以动态扩展，当扩展到无法申请足够内存抛出OutofMemoryError.


> 2.3.3 运行时常量池溢出

- 要向 运行时常量池添加内容，使用String.intern这个native方法实现.该方法作用：如果池中已经包含一个等于此对象的字符串，则返回这个代表池中这个字符串的String对象;否则将字符串添加到字符串常量池，并返回此String对象的引用.

- 由于常量池分配在方法区，可以通过 -XX：PermSize和 -XX：MaxPermSize限制方法区的大小，从而间接限制常量池的容量.


> 2.3.4 方法区溢出
- 方法区用于存放Class的相关信息.
- 方法区溢出是一种常见的内存溢出异常，在动态生成大量Class的应用中，需要特别注意�类的回收状况.
- 方法区溢出常见情况： CGLIB字节码增强，大量JSP的应用程序，基于OSGI的应用
- 即使是同一个类，被不同的加载器也会视为不同的类
- 同一个类被相同的加载器加载两次

> 2.3.5 本机直接内存溢出

- DirectMemory容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认和JVM堆的最大值一样.（-XMX）


# 三. 垃圾收集器与内存分配策略

## 3.1  概述

- 哪些内存需要回收
- 什么时候回收
- 如何回收

## 3.2 引用计数算法
 给对象添加一个引用计数器，每当有一个地方引用他，计数器就加1;当引用失败时，计数器就减一;任何时刻计数器为0就不可以在引用

缺点：**对象之间循环依赖问题**.


## 3.3 根搜索算法

> 通过一系列的名为 'Gc Roots'的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链.当一个对象不可达，则证明对象是不可用的.


> 可以作为Gc Roots的对象包括以下几种：

- 虚拟机栈（栈帧的本地变量表）中的引用的对象
- 方法区中的类静态属性引用的对象
- 方法区中的常量引用的对象
- 本地方法栈JNI（即Native方法）的引用对象


## 3.4 在谈引用

- 强引用  

  直接声明对象引用.虚拟机永远不会回收强引用的对象

- 软引用

  在系统将要发出内存溢出之间，将会把软引用的对象放入回收并进行二次回收.jdk1.2以后提供SoftReference来实现 

- 弱引用
  
  被弱引用关联的对象只能生存到下一次垃圾收集发生之前.jdk1.2以后提供WeakReference来实现 

- 虚引用

  一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象实例.jdk1.2以后提供PhantomReference来实现 


## 3.5 对象生存还是死亡
  
 一个对象真正宣告死亡，至少要经历两次标记过程：如果对象在进行可达性分析之后发现没有与GC Roots相连接的引用链，那它将被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行finalize()方法。

当遇到以下两种情况时，虚拟机将视为“没有必要执行”：
1.对象是否覆盖finalize()方法
2.finalize()方法已经被虚拟机调用过

注：finalize（）能做的所有工作，使用try-finally或其他方式都可以做得更好,更及时

**finalize方法调用的时机**


## 3.6 回收方法区

  永久代主要回收两种：废弃常量和无用的类.
> 同时满足以下几种条件的类才是无用的类

- 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例

- 加载该类的ClassLoader已经被回收

- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 3.7 垃圾回收算法

### 3.7.1 标记-清除算法

> 标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象
缺点：效率问题，标记和清除效率都不高;空间问题，标记清除之后会产生大量不连续的碎片


### 3.7.2 复制算法


> 将可用的内存按容量分为大小相等的两块，每次只使用其中一块。当使用完其中一块，将存活着的对象复制到另一块，再把已使用的块回收.
> 现在商用的虚拟机都采用这种算法来收集新生代

### 3.7.3 标记-整理算法

类似标记-清除，但是标记完后将所有存活的对象向一端移动，然后直接清理掉端边界以外的内存.


### 3.7.4 分代收集算法

将JVM分为年轻代和老年代，针对不同的代特点，采用不同的垃圾回收算法。

年轻代一般采用复制算法，因为对象频繁创建和死去
老年代一般采用标记-清除或者标记-整理算法，因为对象存活率高，且没有多余的内存进行分配担保



## 3.8 垃圾收集器

> 3.8.1 Serial收集器

  串行收集器，缺点：在实现垃圾回收时，必须Stop the world（暂停其他所有的工作线程）,直到收集结束. 单核机器最适合的单线程垃圾收集器.

> 3.8.2 ParNew收集器
  Serial收集器的多线程版本.默认开启的收集线程数与CPU的数量相同.

> 3.8.3 Parallel Scavenge收集器

- 可以使用 -XX：ParallelGCThreads限制垃圾回收的线程数
- 该收集器目标是达到一个可控制的吞吐量= 运行用户代码时间/（运行代码时间+垃圾收集时间）
- 参数-XX：MaxGCPauseMillis参数设置最大垃圾收集停顿时间
- 直接设置吞吐量大小的-XX：GCTimeRatio参数
- 参数-XX：+UseAdaptiveSizePolicy.开关参数，如果打开用户不需要手动指定新生代大小，Eden和Survivor区的比例，晋升老年代年龄等细节参数.虚拟机会根据系统运行情况收集性能监控信息，动态调整这些参数，提供最合适的停顿时间和吞吐量

> 3.8.4 Serial Old 收集器


> 3.8.5 Parallel Old 收集器
 使用多线程和标记-整理算法。

> 3.8.6 CMS 收集器
 
- 一种以获取最短回收停顿时间为目标的收集器.
- 缺点： 
1.CMS收集器对资源非常敏感.默认启动的回收线程数为（CPU+3）/4，当CPU数量较少时，资源会变得紧张. 解决方案：i-CMS，增量式并发收集器.并发标记和并发清理的时候，让GC线程和用户线程交替运行，尽量减少GC线程的独占资源时间，这样整个垃圾回收的过程会更长，但对用户程序的影响就会更小.
2.CMS无法处理浮动资源，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC.由于CMS并发清理阶段用户线程还可能会生成新的垃圾，只能在下一次gc的时候才能清除. 因此CMS需要预留一部分空间，默认是32%。 可以通过参数“-XX：CMSInitiatingOccupancyFraction”来提高触发比。
- 要是预留的空间不足，可能就会触发“Concurrent Mode Failure”.JVM启动后备预案，临时启动Serial Old收集器来进行老年代的垃圾回收. 如果CMSInitiatingOccupancyFraction参数设置太高，可能会频繁触发，反而导致效率不高
3.产生空间碎片.提供参数“XX:+UseCMSCompactAtFullCollection”，当每次fullgc后提供碎片整理功能,空间碎片没了但是停顿时间变长.参数“XX：CMSFullGCsBeforeCompaction”，用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的.


> 3.8.7 G1 收集器
1.基于标记-整理算法
2.非常精准的控制停顿，指定在长度M毫秒的时间片段内，消耗在垃圾回收的时间不得超过N秒
- 每次回收垃圾最多的块，分为2048个块。

**常见收集器组合**
Serial收集器 + Serial Old
ParNew + CMS
Parallel + Parallel Old




**并行和并发的区别**

 并行：多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态

 并发：用户线程和垃圾回收线程同时执行。可能运行


> 对象进入到老年代时机

- 对象年龄达到MaxTenuringThreshold 
- Survivor空间相同年龄所有对象大小的总和达到Survivor空间的一半，年龄大于和等于的对象可以直接进入老年代，无需等到MaxTenuringThreshold 


**空间分配担保**
> 发生Minorgc时候，虚拟机会检查每次晋升到老年代的平均大小是否大于老年代的剩余空间.如果大于直接FullGC，如果小于判断是否HandlePromotionFailure是否允许担保失败;不允许才发生Fullgc，允许发生minorgc

# 4.虚拟机类加载机制

- java中天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的

## 4.1 类加载时机

  类的生命周期包括：加载，验证，准备，解析，初始化，使用，卸载.

> 虚拟机规定以下几种情况必须进行初始化(主动引用)：

- 1.遇到new,getstatic,putstatic,invokestatic这4条字节码
例外：被final修饰，已在编译器把结果放入常量池的静态字段除外

- 2.使用java.lang.reflect包的方法对类进行反射调用，如果类没有初始化，需要先触发初始化

- 3.当初始化一个类的时候，如果发现其父类还没有进行初始化，需要先触发父类的初始化

- 4.当虚拟机启动的时候，需要初始化main方法所在的类

> 被动引用：不会触发初始化


- 1.通过子类引用父类的静态字段，不会导致子类初始化
- 2.通过数组定义来引用类，不会触发此类的初始化
- 3.静态常量已经在编译器放入常量池，不会初始化所在的类

**接口加载与类不同**

-当接口初始化时，不要求父接口都初始化了.只有当真正用到了父接口（如引用接口定义中的常量），才去初始化




